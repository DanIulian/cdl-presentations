\documentclass{beamer}

\usepackage[utf8x]{inputenc} % diacritice
\usepackage[romanian]{babel}
\usepackage{color}			 % highlight
\usepackage{alltt}			 % highlight
\usepackage{code/highlight}	 % highlight
\usepackage{hyperref}        % folositi \url{http://...}
% sau \href{http://...}{Nume Link}
\mode<presentation>
\usetheme{CDL}
                     
% Titlul nu foloseşte Unicode pentru că e o problemă căreia nu i-am dat de
% cap.
\title[Introducere in POO]{Introducere in Programarea Orientata Obiect si C++}
\subtitle{CDL - Cursul 1}
\institute[ROSEdu]{ROSEdu}
\author[Andrada]{Andrada Georgescu}

\begin{document}     

% Slide-urile cu mai multe părţi sunt marcate cu textul (cont.)
\setbeamertemplate{frametitle continuation}[from second]
% Arătăm numărul frame-ului
\setbeamertemplate{footline}[frame number]

\frame{\titlepage}

\begin{frame}
\tableofcontents
\end{frame}

\section{Introducere}

\begin{frame}{Ce este Programarea Orientată Obiect?}
  \begin{itemize} % Just like normal LaTeX
  \item programare procedurală  - o serie de proceduri ce acționează asupra datelor
  \item probleme? 
  \begin{itemize}  
  	\item "reinventarea roții"
	\item dificil de ținut o legătură între date și proceduri
  \end{itemize}
  \item programarea orientată obiect  - datele și procedurile ce acționează asupra acestor date sunt tratate ca un obiect
  \end{itemize}
\end{frame}   

\begin{frame}{Clasă. Obiect.}
  \begin{itemize}
  \item clasă:
  \begin{itemize}
	\item definește caracteristicile abstracte ale unui obiect	
    \item proprietăți + metode
  \end{itemize}
  \item obiect: o \textbf{instanță} a unei clase %, un membru particular ce respectă caracteristicile acelei clase
  \end{itemize}
\end{frame}

\section{Noțiuni de bază C++}

\begin{frame}{Exemplu}
	\footnotesize{\input{code/basic1}}
\end{frame}

\begin{frame}{C++}
  \begin{itemize}
  \item dezvoltat de Bjarne Stroustrup
  \item numit inițial "C cu clase"
  \item ++
    \begin{itemize}
	  \item clase
	  \item transmitere prin referință
	  \item array-uri de lungime variabilă
	  \item etc
	\end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/reference}}
\end{frame}

\begin{frame}{Declarații și definiții}
  \begin{itemize}
  \item metodă (funcție) = declarație + definiție
  \item definiția poate fi făcută și în interiorul declarației clasei 
  \item \textbf{best practice:} declarațiile într-un fișier header, separate de implementare
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
	\footnotesize{\input{code/basic2}}
\end{frame}

\begin{frame}{Specificatori de access: public, private}
  \begin{itemize}
  \item membrii privați: accesați doar din interiorul clasei
  \item membrii publici: accesați prin intermediul oricărui obiect al clasei
  \item implicit: private
  \item regulă generală: variabilele membre vor fi private și se vor defini metode pentru modificarea și accesarea lor - \textbf{set} și \textbf{get} 
  \item \textbf{struct} și \textbf{class}
  \end{itemize}
\end{frame}
               
\begin{frame}{Exemplu}
	\footnotesize{\input{code/access}}
\end{frame}

\begin{frame}{Constructor. Destructor. this}
  \begin{itemize}
  \item constructor: inițializarea membrilor unei clase, alocare memorie
  \item destructor: eliberarea memoriei alocate pentru obiect.
%  \item Dacă nu este declarat un constructor sau un destructor, compilatorul sintetizează unul implicit. Constructorul și destructorul impliciți nu primesc argumente și nu fac nimic.
  \item constructor și destructor impliciți
%  \item Constructorul are același nume cu clasa și nu returnează nimic. Poate primi oricâți parametri.
%  \item Numele destructorului începe cu tildă, urmată de numele clasei. Nu primește parametri și nu returnează nimic.
%  \item Destructorul se va apela când ștergem un obiect alocat dinamic cu operatorul delete sau la ieșirea din scop a obiectului dacă a fost alocat static.
  \item \textbf{new} și \textbf{delete}
  \item \textbf{this} - pointer la obiectul curent
  \end{itemize}
\end{frame}
             
\begin{frame}{Exemplu}
  \footnotesize{\input{code/cons}}
\end{frame} 

\begin{frame}{Exemplu}
  \footnotesize{\input{code/array}}
\end{frame}


\begin{frame}{Supradefinirea funcțiilor și operatorilor}
  \begin{itemize}
  \item în \textbf{C++} este permisă crearea mai multor funcții cu același nume 
  \item funcțiile \textbf{trebuie să difere} prin lista de parametri: tipul lor, numărul lor sau ambele
  \item funcțiile \textbf{nu pot să difere} doar prin tipul returnat
  \item constructorii și metodele unei clase pot fi și ele supradefinite
  \item în \textbf{C++} și operatorii (+, ++, =, +=, * etc) pot fi supradefiniți
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/overload}}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/operator}}
\end{frame}

\section{Concepte de bază ale POO}

\begin{frame}{Concepte de bază ale POO}
  \begin{itemize}
  \item încapsularea
  \item abstractizarea datelor
  \item moștenirea
  \item polimorfismul
  \end{itemize}
\end{frame}

\begin{frame}{Încapsularea}    
 \begin{itemize}
  \item restrângerea accesului la implementare
  \item ascunde detaliile implementării
  \item independența de implementare
  \item utilizare \textbf{set} și \textbf{get}
  \end{itemize}  
\end{frame}

\begin{frame}{Abstractizarea datelor}   
  \begin{itemize}
  \item strâns legată de ideea de încapsulare
  \item un model de reprezentare abstractă a unui obiect real
  \item descompunerea în componente mai mici a unui model foarte complex
  \item caracteristicile esențiale ale obiectului
  \end{itemize}  
\end{frame}

\begin{frame}{Moștenirea}
  \begin{itemize}
  \item un nou tip de date poate definit ca o extensie la un tip deja existent
  \item noua \textbf{subclasă} derivează din (moștenește) \textbf{clasa de bază}
  \item specificatorul de acces \textbf{protected}: accesul permis claselor derivate
  \item \textbf{is-a} vs \textbf{has-a}
  \end{itemize}    
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/derive1}}
\end{frame}   

\begin{frame}{Exemplu}
  \footnotesize{\input{code/derive2}}
\end{frame}

\begin{frame}{Suprascrierea metodelor}
  \begin{itemize}
    \item comportament specific pentru clasa derivată
  	\item suprascrierea unei metode în clasa derivată
	\item ascunderea \textbf{tutoror} metodelor cu același nume din clasa de bază  
  \end{itemize} 
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/override}}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/override2}}
\end{frame}

\begin{frame}{Funcții virtuale}
  \begin{itemize}
	\item funcție virtuală: se stabilește la \textbf{runtime} ce metodă este apelată - \textbf{dynamic binding}
	\item o funcție declarată virtuală rămâne virtuală pe întreg lanțul de moșteniri
	\item destructor virtual: în clasa de bază
	\item mecanismul: \textbf{virtual table}
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/virtual}}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/destructor}}
\end{frame}

\begin{frame}{Funcții pur virtuale și interfețe}
  \begin{itemize}
    \item pur virtual = nu este precizată o implementare în clasa de bază,
	\item clasă abstractă: cel puțin o metodă pur virtuală
	\item o clasă abstractă nu se poate instanția 
	\item interfață: doar funcții pur virtuale - \textbf{abstractizarea datelor}
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/interface}}
\end{frame}

\begin{frame}{Polimorfismul}
  \begin{itemize}
  \item polimorf = mai multe forme 
  \item capacitatea unui tip, de a putea fi folosit ca un alt tip
  \item o implementare specifică a unei interfețe sau a unei clase de bază generice
  \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
  \footnotesize{\input{code/poly}}
\end{frame}

\section{Alte facilități C++}

\begin{frame}{Membri statici și constanți}
 \begin{itemize}
  \item Membri statici:
  \begin{itemize}
  \item aparțin \textbf{clasei}, și nu \textbf{obiectului}
  \item metodele statice pot accesa doar membri statici
  \item pot fi accesați fără a avea o instață a clasei
%  \item Se recomandă să fie accesați prin \textbf{NumeClasă::MembruStatic}, deși se pot accesa și printr-un reprezentant al clasei.
%  \item Sunt comuni și pentru clasele ce derivează o clasă cu membri statici.
  \end{itemize}       
  \item Membri constanți: 
   \begin{itemize}
    \item variabile membre: inițializate de constructor
	\item metode \textbf{const}: nu au dreptul să modifice membrii clasei
   \end{itemize}
   \item Membri \textbf{static const}: pot fi inițializați direct dacă au tip întreg
   \end{itemize}
\end{frame}

\begin{frame}{Exemplu}
	\footnotesize{\input{code/static}}
\end{frame}

\begin{frame}{Alte noțiuni (TODOs)}
  \begin{itemize}
  \item moștenire multiplă, moștenire virtuală
  \item copy-constructor
  \item virtual table
  \item template-uri
  \item STL 
  \item stream-uri
  \item namespace
  \end{itemize}
\end{frame}

\begin{frame}{Cuvinte cheie}
  \begin{itemize}
   \item programare orientată obiect
   \item clasă, obiect
   \item constructor, destructor
   \item nivel de acces
   \item encapsulare
   \item abstractizarea datelor
   \item moștenire
   \item polimorfism
   \item metodă virtuală
   \item clasă abstractă
  \end{itemize}
\end{frame}

\begin{frame}{Referințe recomandate}
  \begin{itemize}
  \item Tutorial C++: \url{http://newdata.box.sk/bx/c/index.htm}
  \item Referințe: \url{http://www.cplusplus.com}
  \item C++ in a Nutshell - Ray Lischner
  \item Effective C++ - Scott Meyers
  \end{itemize}
\end{frame}

\end{document}
